# Angular UI

The project was generated using the Angular CLI "ng" command. At time of writing (Early 2023), it has been upgraded to Angular 13.1. The source code is structured in the standard way that the command works.

Repository: https://github.com/pixlise/pixlise-ui

Development was done on a macbook pro, but the CI process is linux/docker.


## Running locally on a laptop

Tools required generally are:
- npm/node
- Angular cli
- protoc compiler

You may need python3 if you're regenerating the periodic table data (see `/periodictable` directory description below)

To get an up-to-date list, look at the `build-container` repository, which contains a docker container set up with all build tools. This is used in the github CI process, so must be up to date!

Once you have git cloned the repository and started the Go API (see documentation of Go API for this):

Ensure submodules are available:
```
git submodule init
git submodule update
```

Generate protobuf serialisation code:
```
genproto.sh
```

Run angular dev server:
```
cd client
npm i
ng serve
```

This will install npm packages into `/client/node_modules` then start the Angular test server, build the application and serve it on localhost:4200


## Testing

There are some unit tests for the more critical areas of PIXLISE (more for calculations, not so much for widgets/canvas rendering). These tests can be run using the normal `ng test` command.

NOTE: The default Angular cli code generator makes "spec" files with a blank test defined for each class. A lot of these ended up being unused, they're still around in case we want to write tests for those components, but they may not compile in their current form. So only test files marked `*.working.spec.ts` are included in when running the the tests.


## Directory Structure

### Data formats

PIXLISE needs to be able to read the binary dataset and quantification files generated by their respective converters. The files are serialised by Google's Protobuf library - this is a code generator that generates code in whatever language is required, to serialise the files using a "message definition". These are included as a git submodule in `/data-formats`

### Periodic Table

There is a python script to generate periodic table/XRF line data as a .ts file from various sources located in `/periodictable`

### Angular source

`/client` contains the Angular project.

### CI files

All found in the `.github` directory. These form multiple workflows within GitHub for building, testing and packaging the UI.

## Source Directory Contents (/client/src/app)

### /guards
Contains Angular guards (code that allows blocking users from accessing certain routes, eg if they are not yet logged in). 

### /models
Contains commonly used "models" for widgets to use/share/access. Here is a quick summary:
- BasicTypes: Types such as MinMax, and other simple models such as DetectorConfigs, ComponentVersion (for about page), etc.
- DataSet: The `DataSet` class which wraps the Google Protobuf generated Experiment class. On loading, it generates some lookups, works out if it's a tactical dataset, etc. See DataSet service.
- ExperimentSelection: `ExperimentSelection` class which represents a selection of points in the experiment. If the selection came from a region of interest, this will also contain the ROI ID.
- Geometry: Contains basic geometry types like Rect, Point, etc. Also contains matrix/linear algebra/point-with-polygon utility functions.
- LocationData2D: `LocationDataLayer` class used to represent Context Image layer data. This contains histogram data of the maps values and a `LocationDataLayerProperties` to store metadata of the layer.
- Quantifications: `QuantificationLayer` class which stores the data read from a quantification binary file. See Quantification service. This also contains classes that implement the expresison language to query/combine/calculate any data in dataset or quantification. See data expression service. Note: The expression language is unit tested in Quantifications.working.spec.ts

### modules
Contains a module that pulls in all required components from Googles Angular Material library

### periodic-table
The root `/periodic-table` script generates `rawPeriodicTable.ts` in here. The rest of the files are model/utility functions for querying XRF K/L/M/Escape lines, and a model for use in UI elements which display XRF lines.

### protolibs

**NOTE:** Generated Code!

This may not be here when you pull down the dataset. It's generated by `/genproto.sh`, 

### /services
All services used in the application are defined in `/client/src/app/services`. There are several services which encapsulate themes:

- **annotation service**
For create/edit/delete/sharing of user annotations on widgets. Interacts with API. In code, these are defined as class `AnnotationItem`. At time of writing it's only used on the spectrum annotation screen, but it's intended to work on all widgets as we go along.

- **authentication service**
Login to Auth0 (for generation of JWT) or any code which requires knowledge of the logged in user profile/permissions/name/email etc can use this service.

- **context-image service**
The context image widget uses this service in conjunction with other UI components (such as toolbars, context image layers panel, etc) to share the model data of the context image.

The model for the context image (class: `ContextImageModel`) contains all information required to draw the context image widget. This includes all the point x/y coordinates, layer map values for each point, statistics for the layer map scale, etc.

Can notify subscribers if a model is created, to prevent race conditions on startup - see `mdl$`.

- **data-expression service**
For creating/editing/deleting/sharing data expressions, interacts with API.

Expressions are a string containing text in the form of the PIXLISE apps own expression language OR the Lua programming language.. It allows a user to manipulate the data in PIXLISE (read from dataset/quant files) and form something that can be displayed on one of the widgets which support expressions.

Expressions have a random char ID, but there are also "known" aka "predefined" expression IDs used throughout the code which this service can exchange for the actual expression. For example, any code that needs to read quantification (weight %) data for an element can use a "known" ID to build the expression required. It looks like this: `expr-elem-Ca-%` for `element("Ca", "%", "Combined")`.

In code, an expression is defined by class: `DataExpression`.

- **data-module service**
For creating/editing data modules - Lua modules that can be referenced by Lua expressions, interacts with API. These modules can be created, and edited (by creating a new version), but they cannot be deleted. This ensures that expressions will never suffer from "broken references" to a deleted module.

- **expression-runner service**
Runs expressions and supports exporting expressions.

It will run expression with any supported language type, and download/prepare modules as needed.

Exporting is only possible with expressions written in Lua. When these are exported, the source code of the expression and any modules it references are included in a zip file, along with data files in CSV format that the expression reads in. Some Lua stub code is also included to implement the functions available within PIXLISE. This allows executing expressions outside of PIXLISE using the standard Lua interpreter.

- **data-set service**
This allows listing and loading datasets and their corresponding context images into PIXLISE. Interacts with API. Also contains code to export data (downloads zip files to the browser).

The Datasets screen (with dataset tiles) allows users to type filtering criteria to find datasets - these criteria are passed by this service to the API to get filtered lists of datasets to display.

Datasets all contain a `DataSetSummary` class, which is what represents the data shown on the dataset tiles.

When downloading a dataset to open it in PIXLISE, it is represented by a `DataSet` class.

Can be subscribed to for notification when a new dataset is loaded - see `dataset$`. Also provides progress notifications while a quantification is loaded. See `datasetLoadProgress$`.

- **element-set service**
Contains create/list/get/delete/share functionality for element sets. Interacts with API. These are lists of elements that can be saved/loaded/shared between users. They are not simply the elements (stored as atomic numbers) but also allow users to store the toggled state of K/L/M and escape lines for each element.

- **env-configuration service**
Deals with settings/config that controls the environment that quantifications are run in. This currently means getting detector configurations (each dataset has a detector config associated with it), listing piquant downloads and configurations, and querying component versions from the API (for the about page)

- **http-interceptor service**
Intercepts outgoing HTTP messages destined for the API, and adds the JWT (javascript web token) of the logged-in user, as required for the API to process the request.

- **layout service**
This contains UI layout settings and a mechanism to notify canvases when the viewport of the application is resized, so they can also resize their canvas area. This is somewhat in flux, but currently contains settings to control the visibility of panels such as the context image layers and spectrum peak ID configuration panels.

- **quantification service**
This is where to turn to for all quantification functionality. Allows listing quantifications for the loaded dataset, loading quantifications, and allows creating/deleting/sharing quantifications. Interacts with the API. Quantifications are stored/returned as `QuantificationLayer` class objects. Also allows viewing state of all quantification job for admin users.
Can be subscribed to for notification when a new quant is loaded or quantification lists changed - see `quantification$`, `quantificationList$` and `quantificationAdminList$`. 

- **roi service**
Allows creating/deleting/sharing regions of interest (ROI). Interacts with API. Can be subscribed to for changes of ROIs.

- **selection service**
Stores the global list of selected locations in an experiment (PMCs). Can be cleared or replaced with a new selection. This is stored in the view state for persistance. Can be subscribed to for changes in selection.

- **snack service**
Allows display of "Snacks" over each widget. Stores them as a stack, each has an action button that can be clicked and the service can be subscribed to for these events.

- **spectrum-chart service**
Used by spectrum chart widget and associated UI elements to share the model of the spectrum chart (`SpectrumChartModel` class). Can notify subscribers if a model is created, to prevent race conditions on startup - see `mdl$`.

- **user-management service**
Admin feature for management of users in Auth0. Allows searching for users and viewing/editing their roles. This makes it easier to manage users within PIXLISE as users aren't required to also log into Auth0 and know how it works.

- **view-state service**
This allows saving view state in each widget (on change, event driven), and when a new dataset is loaded, it loads the saved view state for each widget. Therefore widgets which are interested in persisting their state can subscribe to `viewState$`.

- **widget-region-data service**
The most important service! This provides a getData() function (and other forms) which widgets can subscribe directly to and only be notified when data is available for the expression they are running. Widget Region Data Service hides all the complexity of checking that ROIs, expressions, view states etc have loaded and will run expressions when ready and return a result.

### /UI/Atoms

Contains commonly used UI "Atoms" such as buttons, sliders, snacks, etc. These are all implemented as Angular components. See source code documentation for more information on each one.

### /UI

All Angular components implementing widgets and significant UI elements are defined here. These include things like the context image, spectrum chart, chord diagram, ternary/binary plots, histogram, scatter plot. Also things like the periodic table, expression editor/picking views, application toolbar, etc.

See source code documentation for more information on each one.

### /utils

Contains various utility functions and a few more significant classes:

- colours
Defines a Colours class which contains RGBA info for all colours used in the UI, and allows generation of colour ramps for various uses, such as expression maps.

- drawing
Contains some utility functions to draw some common UI items like clouds of points (for ternary/binary diagram), buttons (on canvases), etc

### /assets

Standard Angular place to store all assets like button icons, logos, etc

### /environments

Standard Angular environment definitions, `environment.ts` for locally running `ng serve` vs dev/prod/staging environment build settings.

### /scss

Include directory for any global scss files. If you need to @import a common scss file in a component, put it here so it's found by @import.


## More information

For more information consult source code documentation for the API by starting the documentation generator  (see main README for more details)
